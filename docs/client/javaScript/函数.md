## 默认传参

ES5之前是不能默认传参的

参数变量是默认声明的，所以不能用let或 const再次声明

```js
function aa(x,y=10){
    let y = 100; //报错 
    const y = 1000; // 报错
}
```

### 有默认值的参数都不是尾参数

如果传入undefined，将触发该参数等于默认值，null则没有这个 效果

```js
function fn(x,y=1,z){
    return [x,y,z]
}
fn() // [undefined,1,undefined]
fn(1) // [1,1,undefined]
fn(1,,2) //报错
fn(1,undefined,2) //[1,1,2]
```

使用默认值后 length失真

​	这是因为length属性的含义是，该函数预期传入的参数个 数。某个参数指定默认值以后，预期传入的参数个数	就不 包括这个参数了。

​	如果设置了默认值的参数不是尾参数，那么length属性也 不再计入后面的参数了。

```js
(function(a){}).length  //1
(function(a=5){}).length //0
(function(a,b,c=5)).length //2
```



## Rest 参数与 Spread 语法

函数的传参不会因为传入“过多”的参数而报错

```js
function sum(a, b) {
  return a + b;
}
console.log( sum(1, 2, 3, 4, 5) );
```

ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用 arguments对象了。rest 参数搭配的变量是一个数组(是真实数组不是arguments那种的类数组 )，该变量将多余的参数放入数组中。

```js
function fn(a,b,...c){
    console.log(a,b,c) 
}
fn(1,2,3,4,5)  // 1  2  [3,4,5]
```

rest 参数它就是一个真正的数组，数组特有的方 法都可以使用。 rest 参数之后不能再有其他参数（即只能是最后一个参数 ），否则会报错。

## arguments变量

有一个名为 `arguments` 的特殊的类数组对象，该对象按参数索引包含所有参数。

例如：

```javascript
function showName() {
  console.log( arguments.length );
  console.log( arguments[0] );
  console.log( arguments[1] );
  // 它是可遍历的
  // for(let arg of arguments) alert(arg);
}
// 依次显示：2，Julius，Caesar
showName("Julius", "Caesar");
// 依次显示：1，Ilya，undefined（没有第二个参数）
showName("Ilya");
```

在过去，JavaScript 中没有 rest 参数，而使用 `arguments` 是获取函数所有参数的唯一方法。现在它仍然有效，我们可以在一些老代码里找到它。

但缺点是，尽管 `arguments` 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 `arguments.map(...)` 等方法。

此外，它始终包含所有参数，我们不能像使用 rest 参数那样只截取入参的一部分。

因此，当我们需要这些功能时，最好使用 rest 参数。



::: warning 注意

箭头函数是没有 `"arguments"`

如果我们在箭头函数中访问 `arguments`，访问到的 `arguments` 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。

```js
function f() {
  let showArg = () => console.log(arguments[0]);
  showArg();
}

f(1); // 1
```

:::

## 函数的严格模式

ES2016 做了一点修改，规定只要函数参数使用了<u>默认值</u>、 <u>解构赋值</u>、或者<u>扩展运算符</u>，那么函数内部就不能显式设 定为严格模式，否则会报错。
这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候， 先执行函数参数，然后再执行函数体。 这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数 却应该先于函数体执行。 所以在ES6中, 只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。

```js
function aa(a=1){
	'use strict'
}
function bb({a,b}=obj){
	'use strict'
}
```

## 函数的name属性

```js
let namesss = function aa(a=1){
	'use strict'
}
namesss.name // aa
```

## 函数对象NFE

在JavaScript中 函数就是一个对象，他拥有name属性和length属性

```
// name属性let namesss = function aa(a=1){    aa()}namesss.name // aa
// length属性let namesss = function aa(a,b,c){    aa()}namesss.length // 3
```

使用以上的书写方式的好处就是函数内部调用自己不会发生异常，这种写法称为 命名函数表达式

以下是一个异常代码

```
let namesss = function(who) {  if (who) {    console.log(`Hello, ${who}`);  } else {    namesss("Guest"); // Error: sayHi is not a function  }};let welcome = namesss;namesss = null;welcome(); // Error，嵌套调用 sayHi 不再有效！
```

以下是一个正常代码

```
let namesss = function aa(who) {  if (who) {    console.log(`Hello, ${who}`);  } else {    aa("Guest"); // Error: sayHi is not a function  }};let welcome = namesss;namesss = null;welcome(); //  Hello, Guest（嵌套调用有效）
```

##  **Spread**  

 它看起来和 rest 参数很像，也使用 `...`，但是二者的用途完全相反 

 当在函数调用中使用 `...arr` 时，它会把可迭代对象 `arr` “展开”到参数列表中。 

```js
let arr = [3, 5, 1];
console.log( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）
```

```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```



```js
let str = "Hello";
console.log( [...str] ); // H,e,l,l,o


str = "Hello";
// Array.from 将可迭代对象转换为数组
console.log( Array.from(str) ); // H,e,l,l,o
```

> - `Array.from` 适用于类数组对象也适用于可迭代对象。
> - Spread 语法只适用于可迭代对象。

 spread 复制数组对象(浅拷贝)

```js
let arr = [1, 2, {name:"666"}];
let arrCopy = [...arr];
```



## 递归

当一个函数在解决问题的时候可能会调用到其他的函数、部分情况下这个函数会调用到自身，这个就是所谓的递归

```js
// 迭代思路
function pow(x, n) {
  let result = 1;
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
alert( pow(2, 3) ); // 8


// 递归思路
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) ); // 8
```

## 上下文和堆栈

有关正在运行的函数的执行过程的相关信息被存储在其 **执行上下文** 中。

[执行上下文](https://tc39.github.io/ecma262/#sec-execution-contexts) 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，`this` 的值，以及其它的一些内部细节。

一个函数调用仅具有一个与其相关联的执行上下文。

当一个函数进行嵌套调用时，将发生以下的事儿：

- 当前函数被暂停；
- 与它关联的执行上下文被一个叫做 **执行上下文堆栈** 的特殊数据结构保存；
- 执行嵌套调用；
- 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。

## 变量作用域，闭包
所谓的闭包就是函数内部可以访问到其外部的函数中声明的变量和参数，js的函数天生就是一种闭包，除了使用 new Function 的方式
MDN 上面是这么描述闭包的  函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包，每当函数被创建，就会在函数生成时生成闭包。

在每个函数内都存在有一个隐藏属性 `[[Environment]]`,`[[Environment]]`叫做词法环境对象，它在整个脚本文件执行前会产生一个，函数实例化创建后也会产生一个，
`[[Environment]]`属性记录了，当前函数的词法环境对象=>外层函数的词法对象=>全局的词法环境对象，这样会形成一个作用域链。

可以对比下以下代码：

```js
// 代码块1
function fn() {
    let a = 1;
    return function fo() {
        console.log(a++)
    }
}
let x = fn()     x.[[Environment]] 存储了对相应 fn() 调用的词法环境的引用
x();//1
x();//2



// 代码块2
function fn() {
    let a = 1;
    return function fo() {
        console.log(a++)
    }
}
fn()()//1
fn()()//1
```

> 在v8引擎中，在js中定义的全局变量是不会被销毁的，因为随时都可能会用到这个变量

首先在代码块1和代码块2都能看出这个fn是一个闭包函数

代码块1是将运行后的函数赋值给了全局变量,相当于保存了函数返回值到全局变量，fo函数引用到他的外部函数a的变量，所以fn执行完后的作用域相当于一个封闭的空间，同时他又缓存到了全局变量导致这个变量一直不会被回收掉,如何回收掉它呢  直接`x=null` 即可

按权威教科书的解释就是`let x = fn() ` 这个 `x.[[Environment]]` 存储了对于 `fn()` 调用的词法环境的引用

代码块2运行完后直接被垃圾回收机制给回收了，每次调用都是一次新的实例

### 词法环境

`[[Environment]]`

### 垃圾收集

V8

## "new Function" 语法

 一种创建函数的方法。它很少被使用， 一般是在复杂的 Web 应用程序中，我们需要从服务器获取代码或者动态地从模板编译函数时才会使用。 

比如

```js
let str = `
    let a = 7;
    a++;
    console.log(6666,a)
`
let func = new Function(str);
func();  // 666,8
```

一般来说`[[Environment]]`是指向函数创建时的词法环境,但是使用new Function创建一个函数，该函数的`[[Environment]]` 并不指向当前的词法环境，而是指向全局环境。 

 因此，此类函数无法访问外部（outer）变量，只能访问全局变量。 

```js
function getFunc() {
  let value = "test";
  let func = new Function('alert(value)');
  return func;
}
getFunc()(); // error: value is not defined
```

如果这个函数能够访问外部（outer）变量会怎么样？

问题在于，在将 JavaScript 发布到生产环境之前，需要使用 **压缩程序（minifier）** 对其进行压缩 —— 一个特殊的程序，通过删除多余的注释和空格等压缩代码 —— 更重要的是，将局部变量命名为较短的变量。

例如，如果一个函数有 `let userName`，压缩程序会把它替换为 `let a`（如果 a 已被占用了，那就使用其他字符），剩余的局部变量也会被进行类似的替换。一般来说这样的替换是安全的，毕竟这些变量是函数内的局部变量，函数外的任何东西都无法访问它。在函数内部，压缩程序会替换所有使用了使用了这些变量的代码。压缩程序很聪明，它会分析代码的结构，而不是呆板地查找然后替换，因此它不会“破坏”你的程序。

但是在这种情况下，如果使 `new Function` 可以访问自身函数以外的变量，它也很有可能无法找到重命名的 `userName`，这是因为新函数的创建发生在代码压缩以后，变量名已经被替换了。

**即使我们可以在 `new Function` 中访问外部词法环境，我们也会受挫于压缩程序。**

此外，这样的代码在架构上很差并且容易出错。

当我们需要向 `new Function` 创建出的新函数传递数据时，我们必须显式地通过参数进行传递。

## 调度

setTimeout 

setInterval